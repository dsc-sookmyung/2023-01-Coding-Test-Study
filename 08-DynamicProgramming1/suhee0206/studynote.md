# Dynamic Programming

## 목차

- **개념**
  - [다이나믹 프로그래밍](#다이나믹-프로그래밍)
- 문제
  - [11726 2×n 타일링](#11726-2×n-타일링)
  - [11055 가장 큰 증가하는 부분 수열](#11055-가장-큰-증가하는-부분-수열)
  - [9456 스티커](#9456-스티커)
  - [9084 동전](#9084-동전)
  



## 개념

### 다이나믹 프로그래밍

동적 계획법이라고 표현하기도 하는 다이나믹 프로그래밍, Dynamic Programming은 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘이다.

다음 조건을 만족할 때 사용할 수 있다.

1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다. 

피보나치 수열은 이러한 조건을 만족하는 문제다. 다이나믹 프로그래밍을 적용했을 때의 피보나치 수열 알고리즘의 시간 복잡도는 `O(N)`이다.

**다이나믹 프로그래밍의 2가지 방식**

- Top-Down (Memoization)

  탑 다운 방식은 '하향식'이라고도 하며, 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다. 

- Bottom-Up

  보텀업 방식은 '상향식'이라고도 하며, 다이나믹 프로그래밍의 전형적인 형태다. 보텀업 방식에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 부른다.

#### Top-Down

메모제이션, Memoization은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미한다. 메모이제이션은 값을 저장하는 방법이므로 캐싱, Caching이라고도 한다.

메모이제이션은 한 번 구한 정보를 리스트에 저장하는 것으로 구현할 수 있다. 다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때는 이미 구한 정답을 그대로 리스트에서 가져오면 된다.

메모이제이션은 때에 따라서 다른 자료형, 예를 들어 사전(`dict`) 자료형을 이용할 수도 있다. 사전 자료형은 수열처럼 연속적이지 않은 경우에 유용하다. 

```python
# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수(Fibonacci Function)을 재귀함수로 구현(Top-Down 다이나믹 프로그래밍)
def fibo(x):
  # 종료 조건(1 혹은 2일 때 1을 반환)
  if x == 1 or x == 2:
    return 1
  # 이미 계산한 적 있는 문제라면 그대로 반환
  if d[x] != 0:
    return d[x]
  # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
  d[x] = fibo(x - 1) + f(x - 2)
  return d[x]

print(fibo(99))
```

*피보나치 수열을 다이나믹 프로그래밍 없이 재귀 함수로만 표현하면 구현은 간편하지만, `O(2^n)`의 지수 시간이 소요되므로 심각한 문제가 발생할 수 있다.*

#### Bottom-Up

재귀 함수를 사용하면 컴퓨터 시스템에서는 함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을 따라야 하므로 오버헤드가 발생할 수 있다. 따라서 재귀 함수 대신에 반복문을 사용하여 오버헤드를 줄일 수 있다. 

```python
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수(Fibonacci Function) 반복문으로 구현(Bottom-Up 다이나믹 프로그래밍)
for i in range(3, n+1):
  d[i] = d[i - 1] + d[i - 2]
```

#### 다이나믹 프로그래밍 문제 접근

특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인해보자.

일단 단순히 재귀 함수로 비효율적인 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 즉 메모이제이션을 적용할 수 있으면 코드를 개선하는 방법도 좋은 아이디어다.

가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 보텀업 방식으로 구현하는 것을 권장한다. 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문이다. `recursion depth, 재귀 함수 깊이`와 같은 오류가 발생하면, `sys` 라이브러리에 포함되어 있는 `setrecursionlimit()` 함수를 호출하여 재귀 제한을 완화할 수 있다.



## 문제

### [11726 2×n 타일링](https://www.acmicpc.net/problem/11726)

문제) 2xn 크기의 직사각형을 1x2, 2x1 타일로 채우는 방법의 수를 구하라.

분류) 다이나믹 프로그래밍

해설) 2xi 크기의 직사각형을 채우는 방법의 수를 저장하는 DP 테이블을 초기화한다. 1부터 n개의 값을 저장할 예정이고, n이 최대 1,000이므로 크기가 1001인 DP 테이블을 만든다. 우선 계산 가능한 값들을 초기화한다. 2x1 크기의 직사각형을 채우는 방법의 수는 1개(`d[1]=1`), 2x2 크기의 직사각형을 채우는 방법의 수는 2개(`d[2]=2`)다. `d[3]`부터는 점화식을 이용하여 구한다. 2xi 크기의 직사각형은 2x(i-1) 크기의 직사각형 옆에 1x2 타일을 채우거나 2x(i-2) 크기의 직사각형 옆에 2x1 타일 두 개를 채워서 만들 수 있으므로, 점화식은 `d[i] = d[i-1] + d[i-2]`이 나온다.

```python
import sys

read = sys.stdin.readline
n = int(read())

d = [0]*(1001)
d[1] = 1
d[2] = 2
for i in range(3, n+1):
  d[i] = (d[i-1] + d[i-2]) % 10007

print(d[n])
```



### [11055 가장 큰 증가하는 부분 수열](https://www.acmicpc.net/problem/11055)

문제) 수열 A가 주어졌을 때, 그 수열의 증가하는 부분 수열 중에서 합이 가장 큰 것을 구하라.

분류) 다이나믹 프로그래밍

해설) DP 테이블에 i번째 값을 포함하는 가장 큰 증가하는 부분 수열을 저장한다. 따라서 D[i]를 A[i]로 초기화한다. for문을 돌면서 현재 인덱스(i번째 인덱스)보다 왼쪽에 있는 값들과 비교를 한다. j번째 값(왼쪽에 있는 값)보다 현재 인덱스에 있는 값이 크고, j번째 값을 포함하는 가장 큰 증가하는 부분 수열에 현재 인덱스 값을 더해서 D[i]에 저장된 값보다 크다면, D[i]를 갱신한다. 현재 인덱스보다 왼쪽에 있는 모든 값들에 대해 앞의 과정을 거쳐서 D[i]를 구한 후. 가장 큰 증가하는 부분 수열 answer보다 D[i]가 크다면 answer를 갱신해준다. 이 과정을 N번째 인덱스까지 반복해주면 된다.

```python
import sys

read = sys.stdin.readline
N = int(read())
A = list(map(int, read().split()))
d = [x for x in A]
answer = d[0]

for i in range(N):
  for j in range(i+1):
    if (A[j] < A[i]) and (d[j] + A[i] > d[i]):
      d[i] = d[j] + A[i]
  answer = max(d[i], answer)

print(answer)
```



### [9456 스티커](https://www.acmicpc.net/problem/9456)

문제) 2행 n열로 배치되어 있는 스티커가 있다. 각 스티커에는 점수가 매겨져있는데, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유하지 않는 스티커 집합을 구하라.

분류) 다이나믹 프로그래밍

해설) 2차원 DP 테이블을 이용한다. `d`의 `i`번째 인덱스에는 `i`열 1행(`d[i][0]`)과 `i`열 2행(`d[i][1]`) 각 위치에 해당하는 스티커의 점수를 포함한, 최대 점수가 저장되어 있다. 따라서 1열을 초기화한 후에, 각 위치의 최대값은 점화식을 이용해 구한다. 각 위치의 스티커 점수(`stickers[행][i]`)는 항상 더해주고, 좌측 대각선 값과 `i-2`번째 열의 최대 점수 중 큰 값을 더한다. 마지막 열에 있는 값을 포함한 점수가 가장 클 수도 있고, 마지막 직전 열에 있는 값을 포함한 점수가 가장 클 수도 있으므로 두 값 중 더 큰 값이 정답이다. 

메모) 질문 게시판 보고, 다섯번의 시도만에 푼 문제다.

일부만 저장하려고 하면 안되고, [9084 동전 문제](https://www.acmicpc.net/problem/9084)처럼, 모든 경우를 DP 테이블에 저장해야된다. 

```python
import sys

read = sys.stdin.readline
T = int(read())
for _ in range(T):
  n = int(read())
  stickers = []
  for _ in range(2):
    stickers.append([0]+list(map(int, read().split())))
  d = [[0,0] for _ in range(n+1)]
  d[1][0] = stickers[0][1]
  d[1][1] = stickers[1][1]
  for i in range(2, n+1):
    d[i][0] = max(d[i-1][1], max(d[i-2])) + stickers[0][i]
    d[i][1] = max(d[i-1][0], max(d[i-2])) + stickers[1][i]
  print(max(max(d[n]), max(d[n-1])))
```



### [9084 동전](https://www.acmicpc.net/problem/9084)

문제) 동전의 종류가 주어질 때에 주어진 금액 M을 만드는 모든 방법을 세라.

분류) 다이나믹 프로그래밍

해설) 동전의 최대 금액이자, 동전으로 만들어야 할 최대 금액인 10,000을 기준으로 DP 테이블의 크기를 초기화한다. (1번째 인덱스부터 사용할 것이므로 10000 + 1로 초기화) 모든 동전에 대해 1원부터 M원까지 각 동전을 더해서 금액을 만드는 방법을 더한다. 동전이 오름차순으로 주어지므로, 작은 동전부터 시작해서, 해당 동전을 더해 만들 수 있는 금액을 갱신해준다. 

```python
import sys

read = sys.stdin.readline
T = int(read())
for _ in range(T):
  N = int(read())
  coins = list(map(int, read().split()))
  M = int(read())
  
  d = [0]*(10001)
  
  for coin in coins:
    d[coin] += 1
    for i in range(coin, M+1):
      d[i] += d[i-coin]

  print(d[M])
```

메모) 잘못 생각했던 부분 정리

1. 모든 동전에 대해 처음부터 더해갔어야 됐는데, 처음 풀이할 때 다음과 같이 잘못 작성했다.

   ```python
   for coin in coins:
   	d[coin] = 1
     for i in range(coins[0]+1, M+1):
       for coin in coins:
         if d[i-coin]:
           d[i] += d[i-coin]
   ```

2. 첫 제출에 DP 테이블 크기를 `M+1`로 둬서  [런타임 에러 (IndexError)](https://www.acmicpc.net/help/rte)가 발생했다. 동전의 금액이 `M`보다 클 수 있다는 사실을 간과했다. 따라서 동전의 최대 금액인 10000을 기준으로 DP 테이블의 크기를 설정했다. 