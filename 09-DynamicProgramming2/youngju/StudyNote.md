# DynamicProgramming2 
## 1149 RGB거리 
어떤 집을 R,G,B로 칠할 때 가능한 모든 경우의 수를 생각해서 dp리스트를 채운다 

```python
import sys

read = sys.stdin.readline

n = int(read())
costs = [list(map(int, read().split())) for _ in range(n)]
dp = [[0]*3 for i in range(n+1)]

for i in range(1, n+1):
    dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + costs[i-1][0]
    dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + costs[i-1][1]
    dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + costs[i-1][2]

print(min(dp[n][0], dp[n][1], dp[n][2]))
```

**[풀이]**
1) 집마다 R,G,B로 칠할 때 드는 비용을 costs에 저장
2) 어떤 집을 R,G,B중 하나로 칠할 때 드는 비용을 구하기 위해 dp리스트를 [0,0,0]이 n+1개 들어있는 이중리스트로 만든다
3) dp리스트의 인덱스 1부터 n까지 돌면서 각 집을 R,G,B로 칠했을 때의 비용을 채운다
4) 이때 dp[x][0]은 R로 칠했을 때이고 dp[x][1]은 G로 칠했을 때, dp[x][2]는 B로 칠했을 때를 말한다
5) 따라서 각 경우의 수에 대해 그 전 인덱스의 현재 자신이 칠할 색과 다른 색 두 개의 값을 비교해서 더 작은 값과 현재 자신이 칠할 색의 비용을 더해서 값을 업데이트한다 
6) dp리스트의 마지막 인덱스에서 가장 최솟값을 출력 

<br/>

## 2156 포도주 시식 
dp리스트를 채우는 방법을 알아야 한다 

```python
import sys

read = sys.stdin.readline

n = int(read())
wine = [0] + [int(read()) for _ in range(n)] + [0]
dp = [0] * (n+2)
dp[1] = wine[1]
dp[2] = wine[1] + wine[2]

for i in range(3, n+1):
    dp[i] = max(dp[i-1], dp[i-2] + wine[i], dp[i-3] + wine[i-1] + wine[i])

print(dp[n])
```

**[풀이]**
1) 포도주 양을 wine리스트에 저장한다
2) dp리스트를 만드는데 이때 연속해서 3개를 마실 수 없으므로 예를 들어 x번째 포도주를 마실지 안 마실지 결정하려면 x-2, x-1번째 포도주를 마셨는지 안 마셨는지를 확인해야 한다. 따라서 dp리스트를 n+2길이로 만든다
3) dp리스트의 초기값을 정할 때 dp[2]는 포도주 첫 번째와 두 번째를 다 마시는 것이 가능하므로 앞에서 두 개를 모두 더한 것인데 이때 만약 n이 1이라면 wine[2]에서 인덱스 에러가 발생하므로 wine리스트의 가장 앞에 [0]을 붙여주고 dp와 길이를 맞추기 위해 마지막에도 [0]을 붙여준다
4) 그러면 for문을 돌면서 dp값을 채워준다
5) dp[i]는
		(1)  i-2, i-1번째까지 다 마셨을 경우에 dp[i-1]값을 그대로 업데이트
		(2) i-2번째만 마시고 i-1번째를 안 마시고 i번째 포도주를 마시는 경우
		(3) i번째와 i-1번째 포도주를 연속해서 마신다면 i-2번째는 마시지 않아야 하므로 dp[i-3]값에 더하는 경우
   세 가지 경우가 있으므로 각 경우의 값을 구해서 그 중 최댓값으로 dp[i]를 채운다
6) dp[n]을 출력한다 

<br/>

##  1463 1로 만들기 
1을 빼는 연산을 기준으로 푼다! 이 아이디어를 떠올리지 못해서 구글링을 통해 이해했다 

```python
n = int(input())  
dp = [0] * (n+1)  
  
for i in range(2, n+1):  
    dp[i] = dp[i-1] + 1  
  if i % 3 == 0:  
        dp[i] = min(dp[i], dp[i//3] + 1)  
    if i % 2 == 0:  
        dp[i] = min(dp[i], dp[i//2] + 1)  
  
print(dp[n])
```

**[풀이]**
1) 정수 n을 입력 받고 dp리스트를 n+1길이로 만든다 
2) dp[i]에 i가 1이 되기 위해 필요한 연산 횟수를 저장
3) 따라서 dp[0]과 dp[1]은 0이 되고 dp[2]부터 계산한다
4) i가 1이 되기 위해 필요한 연산 횟수는 일단 i-1보다 1이 더 크므로 dp[i]는 dp[i-1]에 1을 더하는 연산을 더해 dp[i-1]+1로 초기화를 한다
5) 만약 i가 3이나 2로 나누어진다면 i//3, i//2인덱스의 dp값에 +1을 한 값이 될 수도 있으므로 각 경우마다 초기화한 값과 비교해서 더 작은 값으로 덮어쓴다
6) dp[n]을 출력 

<br/>

## 12865 평범한 가방 
저번 주차에서 풀었던 "동전" 문제와 유사한 방식으로 푼다!

```python
import sys  
  
read = sys.stdin.readline  
n, k = map(int, read().split())  
bag = [(0, 0)]  
dp = [[0] * (k + 1) for _ in range(n + 1)]  
for _ in range(n):  
    w, v = map(int, read().split())  
    bag.append((w, v))  
  
for i in range(1, n + 1):  
    for j in range(1, k + 1):  
        w = bag[i][0]  
        v = bag[i][1]  
        if j < w:  
            dp[i][j] = dp[i - 1][j]  
        else:  
            dp[i][j] = max(dp[i - 1][j], v + dp[i - 1][j - w])  
  
print(dp[n][k])
```

**[풀이]**
1) 물건의 무게와 가치를 튜플로 받아 bag리스트에 저장한다
2) dp는 열이 k까지의 무게를 나타내고 행이 총 n+1길이인 이중리스트로 만든다
3) 첫 번째 행부터 돌면서 dp의 값을 채워넣는다
4) 물건의 무게가 현재 가리키고 있는 인덱스(j, 무게)보다 크다면 물건을 담을 수 없으므로 바로 그 전 행의 값을 가져와서 값을 초기화한다
5) 만약 물건의 무게가 작거나 같아서 담을 수 있다면 그 물건을 담았을 때와 담지 않았을 때를 비교해야 하므로 그 전 행의 값과 그 전 행의 해당 물건의 무게만큼을 뺀 곳의 dp값을 비교해서 더 큰 값으로 초기화한다
6) 그리고 dp[n][k]의 값을 출력한다 
